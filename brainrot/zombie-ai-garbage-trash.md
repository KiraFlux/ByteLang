# ByteLang - Спецификация на основе вашего примера

## 1. Основные концепции

### 1.1 Память
- **Глобальные переменные** - статические адреса в data-секции
- **Локальные переменные** - в стеке текущего кадра функции
- **Стек** - растёт вверх, используется для параметров, возвращаемых значений и локальных переменных

### 1.2 Соглашение о вызовах
- Аргументы передаются через стек
- Возвращаемое значение кладётся на стек перед `ret()`
- Для функций с возвращаемым типом автоматически создаётся переменная `return`

## 2. Синтаксис

### 2.1 Модули
```rust
import math
import stack
import func
import mem
```

### 2.2 Переменные
```rust
// Глобальные (в data-секции)
var x: i16 = 20

// Локальные (в стеке функции)
fn example() void {
    var local: i16
}
```

### 2.3 Функции
```rust
// Нативные (индексы определяются интерпретатором)
pub fn add(ret: *i16, a: *i16, b: *i16) void = 0x67
pub fn load(target: *i16, value: i16) void = 0x42
pub fn push_var(source: *i16) void = 0x49
pub fn push_const(value: i16) void = 0x50
pub fn pop_in(dest: *i16) void = 0x51
pub fn alloc(len: usize) void = 0x52
pub fn call(func: *void) void = 0x53
pub fn ret() void = 0x54

// Пользовательские
fn calc(x: i16, y: i16) i16 {
    // автоматически создаётся переменная `return: i16`
    // ...
}
```

## 3. Инструкции байт-кода

### 3.1 Математика (`math.bl`)
```rust
0x67: add(ret: *i16, a: *i16, b: *i16)    // *ret = *a + *b
// Аналогично: sub, mul, div
```

### 3.2 Память (`mem.bl`)
```rust
0x42: load(target: *i16, value: i16)      // *target = value
```

### 3.3 Стек (`stack.bl`)
```rust
0x49: push_var(source: *i16)              // *SP = *source; SP += 2
0x50: push_const(value: i16)              // *SP = value; SP += 2
0x51: pop_in(dest: *i16)                  // *dest = *SP; SP -= 2
0x52: alloc(len: usize)                   // SP += len
```

### 3.4 Функции (`func.bl`)
```rust
0x53: call(func: *void)                   // call procedure
0x54: ret()                               // return from procedure
```

## 4. Модель выполнения

### 4.1 Состояние VM
```c
typedef struct {
    uint8_t* data;          // data секция
    uint16_t data_size;
    
    uint8_t* code;          // code секция
    uint16_t code_size;
    
    uint16_t* stack;        // стек
    uint16_t stack_size;
    uint16_t sp;            // stack pointer
    uint16_t fp;            // frame pointer (текущий кадр)
    uint16_t ip;            // instruction pointer
    
    uint16_t return_addr;   // адрес возврата
} VM;
```

### 4.2 Вызов функции `calc(100, x)`

#### Состояние стека:
```
До вызова:
SP -> ...

push_const(100):
SP -> [100]

push_var(x):
SP -> [100, значение_x]

alloc(2): // sizeof(i16)
SP -> [100, значение_x, неинициализировано]

call(calc):
SP -> [100, значение_x, неинициализировано, адрес_возврата]
IP = адрес calc
FP = SP // устанавливаем начало нового кадра
```

#### Внутри функции `calc`:
```
Кадр стека:
[FP-6] = 100 (параметр x)
[FP-4] = значение_x (параметр y) 
[FP-2] = неинициализировано (возвращаемое значение)
[FP]   = адрес_возврата

Адреса параметров:
x = FP-6
y = FP-4
return = FP-2
```

#### Код `calc`:
```
mem.load(return, 5)    // *return = 5
math.add(return, x, y) // *return = *return + *x + *y
func.ret()             // возврат
```

#### Инструкция `ret()`:
1. Восстанавливает IP из адреса возврата
2. Восстанавливает FP из предыдущего значения
3. Устанавливает SP = FP - 6 (очищает кадр, но оставляет возвращаемое значение на вершине)

#### После возврата:
```
SP -> [возвращаемое_значение]
pop_in(x) // x = возвращаемое_значение
```

## 5. Компиляция

### 5.1 Компилятор должен:
1. Для каждой функции:
   - Вычислить размер кадра (параметры + локальные переменные + возвращаемое значение)
   - Назначить смещения для всех переменных
   
2. Преобразовать обращения к переменным в адреса:
   - Глобальные → абсолютные адреса в data-секции
   - Параметры и локальные → смещения от FP

### 5.2 Пример компиляции функции `calc`

#### Исходный код:
```rust
fn calc(x: i16, y: i16) i16 {
    mem.load(return, 5)
    math.add(return, x, y)
    func.ret()
}
```

#### Компилированный байт-код:
```
; mem.load(return, 5)
[0x42] [FP-2] [0x0005]  ; load(return, 5)

; math.add(return, x, y)
[0x67] [FP-2] [FP-6] [FP-4]  ; add(return, x, y)

; func.ret()
[0x54]  ; ret
```

## 6. Полный пример программы

### 6.1 Модуль `math.bl`
```rust
// Все операции работают с адресами
pub fn add(ret: *i16, a: *i16, b: *i16) void = 0x67
pub fn sub(ret: *i16, a: *i16, b: *i16) void = 0x68
pub fn mul(ret: *i16, a: *i16, b: *i16) void = 0x69
pub fn div(ret: *i16, a: *i16, b: *i16) void = 0x6A
```

### 6.2 Модуль `mem.bl`
```rust
pub fn load(target: *i16, value: i16) void = 0x42
pub fn copy(source: *i16, dest: *i16) void = 0x43  // *dest = *source
```

### 6.3 Модуль `stack.bl`
```rust
pub fn push_var(source: *i16) void = 0x49
pub fn push_const(value: i16) void = 0x50
pub fn pop_in(dest: *i16) void = 0x51
pub fn alloc(len: usize) void = 0x52
```

### 6.4 Модуль `func.bl`
```rust
pub fn call(func: *void) void = 0x53
pub fn ret() void = 0x54
```

### 6.5 Модуль `sketch.bl`
```rust
import math
import mem
import stack
import func

// Глобальные переменные
var x: i16 = 20
var result: i16

// Функция: result = 5 + x + y
fn calc(x: i16, y: i16) i16 {
    // return = 5
    mem.load(return, 5)
    
    // return = return + x + y
    // Для этого нужно: return = return + x, затем return = return + y
    // Или добавить инструкцию add3?
    // Временно используем временную переменную
    var temp: i16
    
    // temp = x + y
    math.add(temp, x, y)
    
    // return = return + temp
    math.add(return, return, temp)
    
    func.ret()
}

// Главная функция
pub fn main() void {
    // Вызов calc(100, x)
    
    // Параметр 1: 100
    stack.push_const(100)
    
    // Параметр 2: значение x
    stack.push_var(x)
    
    // Место для возвращаемого значения
    stack.alloc(sizeof(i16))  // 2 байта
    
    // Вызов функции
    func.call(calc)
    
    // Забираем результат
    stack.pop_in(result)
    
    // Теперь result = calc(100, 20) = 125
}
```

## 7. Особенности реализации

### 7.1 Адресация
Компилятор заменяет имена переменных на адреса:
- Глобальные: `x` → абсолютный адрес (например, `0x0100`)
- Локальные: `return` → `FP-2`, `x` (параметр) → `FP-6`

### 7.2 Размер кадра
Для функции `calc(x: i16, y: i16) i16`:
- Параметры: 2 × i16 = 4 байта
- Возвращаемое значение: 1 × i16 = 2 байта
- Локальные переменные: `temp: i16` = 2 байта
- Итого: 8 байт

### 7.3 Инструкция `call`
1. Сохраняет текущий IP в стеке
2. Устанавливает FP = SP (начало нового кадра)
3. Переходит по адресу функции

### 7.4 Инструкция `ret`
1. Восстанавливает IP из стека
2. Восстанавливает предыдущий FP
3. Корректирует SP: SP = FP - размер_кадра + 2 (оставляя возвращаемое значение)

## 8. Преимущества данного подхода

1. **Единообразие**: все операции работают с адресами
2. **Простота**: минимальный набор инструкций
3. **Эффективность**: прямой доступ к памяти
4. **Гибкость**: можно реализовать любые соглашения о вызовах

## 9. Ограничения и возможные улучшения

1. **Нет операторов**: только вызовы функций
2. **Многословность**: для простых операций нужно много кода
3. **Ручное управление стеком**: программист должен явно управлять стеком

Возможные улучшения:
- Макросы для часто используемых паттернов
- Автоматическая оптимизация временных переменных
- Поддержка составных типов (массивы, структуры)

Данная спецификация предоставляет рабочую основу для языка с полным контролем над памятью и стеком.