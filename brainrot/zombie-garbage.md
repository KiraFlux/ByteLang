# ByteLang - Спецификация языка

## Философия
Простой статический язык для встроенных систем. Контроль как в ассемблере, удобство как в высокоуровневых языках.

## Основные принципы
1. **Для человека**: понятный синтаксис, автоматизация рутины
2. **Для машины**: линейный байт-код, минимальные накладные расходы
3. **Формат исполнения**: `[индекс_функции] [аргумент1] [аргумент2] ...`

## Синтаксические элементы

### Идентификатор
```
identifier = [A-Za-z_][A-Za-z0-9_]*
```

### Типы
```
type = "u8" | "i8" | "u16" | "i16" | "u32" | "i32" | "f32" | "void"
      | "*" type
      | "[" const_expr "]" type
      | identifier  // пользовательский тип
```

### Модуль
Файл `.bl`, содержит реестр значений. Значения регистрируются лениво.

### Импорт
```rust
import math  // добавляет публичные идентификаторы math в реестр
```

### Константы
```rust
const PI = 3.14
pub const MAX = 255  // доступна при импорте
```

### Переменные
```rust
var x: i16 = 5
var y: u8 = undefined
```

### Структуры
```rust
struct Point {
    x: i16,
    y: i16,
}
```

## Функции

### Нативные функции
Реализованы в интерпретаторе:
```rust
fn add(a: i16, b: i16, dest: *i16) void = 0x10
```

### Пользовательские функции
Реализованы в ByteLang:
```rust
fn calculate(x: i16) i16 {
    var result = math.add(x, 10)
    return result
}
```

### Особые функции
```rust
// Встроенные управляющие функции
fn exit() void = 0x00        // завершение программы
fn goto(addr: ptr) void = 0x01  // безусловный переход
```

## Проблема и решение: вложенные вызовы

### Проблема
Исходный код с вложенными вызовами:
```rust
var u = math.mul(kp, math.sub(gray, readLine()))
```

Нужно преобразовать в линейный байт-код.

### Решение: автоматическое разворачивание
Компилятор автоматически создает временные переменные:
```
1. t1 = readLine()
2. t2 = math.sub(gray, t1)
3. u = math.mul(kp, t2)
```

## Механизм компиляции

### 1. Разрешение вложенных вызовов
Для каждого вложенного вызова создается временная переменная в data-секции.

### 2. Передача аргументов
Аргументы передаются непосредственно в байт-коде:
- Константы: передаются как есть
- Переменные: передаются их адреса в data-секции
- Временные переменные: передаются их адреса

### 3. Формат вызова функции
```
[индекс_функции: 1 байт] [арг1] [арг2] ... [аргN]
```

### 4. Возвращаемые значения
- Чистые функции: результат записывается во временную переменную
- Процедуры (void): работают через указатели

## Точка входа

### Правила
1. Должна существовать функция `main` с модификатором `pub`
2. Код `main` размещается первым в секции code
3. После последней инструкции `main` добавляется `0x00` (HALT)

### Пример
```rust
pub fn main() void {
    // код программы
}
```

Компилируется в:
```
[код main...]
0x00  // завершение программы
```

## Управление потоком

### Циклы
```rust
loop {
    // бесконечный цикл
}
```

Преобразуется в:
```
начало_цикла:
    [тело цикла]
    goto начало_цикла
```

### Условные переходы (предложение)
Добавить инструкции:
- `goto_if(condition, addr)` - условный переход
- `compare(a, b, result)` - сравнение с записью результата

## Формат .blc файла

### Структура
```
Заголовок (2 байта):
    [0] = 0x42  // сигнатура 'B'
    [1] = размер_data_секции

Секция данных:
    [0..N] = глобальные переменные, временные переменные

Секция кода:
    [0]..     = код функции main
    ...       = другие функции
    последний = 0x00 (HALT)
```

### Размещение переменных
Все переменные (глобальные, локальные, временные) размещаются в data-секции. Адрес переменной - это ее смещение в data-секции.

## Модель исполнения

### Интерпретатор
```c
struct VM {
    uint8_t* data;      // секция данных
    uint8_t* code;      // секция кода
    size_t ip;          // instruction pointer
};
```

### Алгоритм исполнения
1. Читаем байт по адресу `ip` - индекс функции
2. Определяем количество аргументов из сигнатуры функции
3. Читаем аргументы
4. Выполняем нативную функцию
5. `ip += 1 + размер_аргументов`
6. Повторяем

### Нативные функции
Получают:
- Указатель на VM
- Массив аргументов
- Доступ к data-секции через VM

## Пример полной компиляции

### Исходный код
```rust
// math.bl
pub fn add(a: i16, b: i16, dest: *i16) void = 0x10

// program.bl
import math

pub fn main() void {
    var x: i16 = undefined
    math.add(5, 3, &x)
}
```

### Компилированный байт-код
```
data секция (2 байта):
    [0-1]: x (не определено)

code секция:
    [0]: 0x10      // add
    [1-2]: 0x05 0x00  // аргумент 1: 5 (i16)
    [3-4]: 0x03 0x00  // аргумент 2: 3 (i16)  
    [5]: 0x00      // аргумент 3: адрес x (0x00)
    [6]: 0x00      // HALT
```

## Нерешенные вопросы

### 1. Управление памятью временных переменных
Как эффективно распределять и освобождать временные переменные?

**Предложение**: использовать статическое распределение на этапе компиляции.

### 2. Рекурсия
Поддерживать ли рекурсию? Если да, то как ограничить глубину?

**Предложение**: ограничить глубину вызовов, добавить стек вызовов в VM.

### 3. Составные типы в аргументах
Как передавать структуры и массивы?

**Предложение**: передавать по указателю, копирование запрещено.

### 4. Сериализация сложных выражений
Выражения типа `a + b * c` - нужны ли операторы?

**Предложение**: только вызовы функций, операторы реализуются как функции.

## Преимущества подхода

### 1. Простота интерпретации
Интерпретатор ~100 строк кода на C.

### 2. Предсказуемое исполнение
Нет сборки мусора, нет динамического выделения памяти.

### 3. Легкая отладка
Байт-код напрямую соответствует исходному коду.

### 4. Кроссплатформенность
Один и тот же байт-код на разных архитектурах.

## Ограничения

### 1. Отсутствие динамической памяти
Все переменные статически размещены.

### 2. Ограниченная выразительность
Нет объектов, замыканий, исключений.

### 3. Ручное управление памятью
Программист сам следит за адресами переменных.

## Статус
Спецификация в разработке. Основные концепции определены, требуется проработка деталей реализации компилятора.