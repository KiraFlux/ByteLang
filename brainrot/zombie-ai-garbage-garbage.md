# ByteLang - Минималистичная спецификация

## Основные принципы (без украшательств)
1. Линейный байт-код: `[индекс_функции] [аргумент1] [аргумент2] ...`
2. Глобальные переменные в data-секции
3. Локальные переменные на стеке (для поддержки рекурсии)
4. Аргументы передаются через байт-код (как раньше)
5. Все временные переменные для выражений - тоже на стеке

## Формат .blc файла
```
[0-1]: 0x42 data_size  // заголовок
[2...]: data секция     // глобальные переменные
[...]: code секция      // код программы
```

## Внесенные изменения

### 1. Добавлен стек
- Растет вверх
- Для каждой функции свой кадр
- Локальные переменные имеют отрицательные смещения от Frame Pointer

### 2. Новые нативные инструкции
```rust
// Управление стеком
fn push(size: u16) void = 0x40      // резервировать место
fn pop(size: u16) void = 0x41       // освободить место

// Работа с локальными переменными
fn store_local(value: i16, offset: i16) void = 0x42  // запись
fn load_local(dest: *i16, offset: i16) void = 0x43   // чтение

// Управление кадрами
fn enter() void = 0x44    // сохранить FP, установить FP = SP
fn leave() void = 0x45    // восстановить FP и SP
```

### 3. Функции времени компиляции
```rust
// Вычисляются компилятором, не попадают в байт-код
comptime fn size_of(T: type) usize      // размер типа
comptime fn stack_usage() usize         // размер стека текущей функции
```

## Пример работы

### Исходный код
```rust
// math.bl
pub fn add(a: i16, b: i16, dest: *i16) void = 0x10

// program.bl
import math

fn calculate(x: i16, y: i16) i16 {
    var local1: i16    // FP - 2
    var local2: i16    // FP - 4
    var result: i16    // FP - 6
    
    stack.push(6)                     // резервируем стек
    
    stack.store_local(x, -2)          // local1 = x
    stack.store_local(y, -4)          // local2 = y
    
    // Вычисление: result = local1 + local2
    var temp1: i16, temp2: i16        // временные на стеке
    stack.load_local(&temp1, -2)      // загрузить local1
    stack.load_local(&temp2, -4)      // загрузить local2
    math.add(temp1, temp2, &result)   // сложить
    
    stack.pop(6)                      // освободить стек
    return result
}

pub fn main() void {
    var global_result: i16 = 0
    global_result = calculate(10, 20)
}
```

### Компилированный байт-код (псевдо)
```
main:
    // Глобальная переменная global_result по адресу 0x00
    
    // Вызов calculate(10, 20)
    [0x10] [0x0A 0x00] [0x14 0x00] [0x??]  // math.add? Нет!
    // Нужен call calculate
    
    // Но call у нас нет - функция встроена?
    // Или нужно добавить инструкции вызова?
```

## Проблемы и решения

### Проблема 1: Как вызывать пользовательские функции?
**Решение**: Нужны инструкции call/ret
```rust
fn call(func_addr: u16) void = 0x46    // вызов функции
fn ret() void = 0x47                    // возврат из функции
```

### Проблема 2: Как передавать параметры?
**Варианты**:
1. Через стек (классический подход)
2. Через временные переменные в data-секции (как раньше)
3. Через байт-код (как раньше, но для пользовательских функций сложно)

**Выбрано**: Параметры передаются через стек
- Вызывающая функция кладет аргументы на стек
- Вызываемая функция берет их оттуда

### Проблема 3: Как возвращать значения?
**Решение**: Через стек
- Функция кладет результат на стек
- Вызывающая забирает его

## Обновленная архитектура

### Инструкции
```
0x00: halt                 // завершение программы
0x40: push size            // резервировать стек
0x41: pop size             // освободить стек
0x42: store_local val off  // запись в локальную переменную
0x43: load_local dest off  // чтение из локальной переменной
0x44: enter                // вход в кадр
0x45: leave                // выход из кадра
0x46: call addr            // вызов функции
0x47: ret                  // возврат из функции
0x48: push_arg val         // положить аргумент на стек
0x49: pop_result dest      // забрать результат со стека
```

### Пример с вызовом
```rust
fn add(a: i16, b: i16) i16 {
    enter()                // создаем кадр
    push(2)                // место для результата
    
    var result: i16        // локальная переменная
    
    // Берем аргументы из стека вызова
    // (по смещениям относительно FP)
    
    // Вычисление
    // ...
    
    // Кладем результат на стек возврата
    // ...
    
    pop(2)
    leave()
    ret()
}

fn main() void {
    // Вызов add(5, 3)
    push_arg(5)
    push_arg(3)
    call(add)
    pop_result(&global_var)
}
```

## Итоговая модель

### Стек вызовов
```
Высокие адреса
    ...
    | арг2      |
    | арг1      |  ← аргументы для текущего вызова
    | ret addr  |  ← адрес возврата
    | old FP    |  ← сохраненный FP
    | локальная |  ← локальные переменные
    | локальная |
    ...         |
Низкие адреса
```

### Алгоритм вызова
1. Кладем аргументы на стек
2. `call` - сохраняет IP на стеке, прыгает к функции
3. Функция: `enter` → `push` локальных → выполнение → `pop` → `leave` → `ret`
4. `ret` - восстанавливает IP, очищает аргументы со стека

## Что не хватает?
1. Реализация стековых операций в VM
2. Механизм разрешения адресов (глобальные/локальные)
3. Поддержка временных переменных на стеке
4. Интеграция с существующими нативными функциями

## Простейшая реализация (без рекурсии)
Если рекурсия не нужна сразу:
- Локальные переменные делаем глобальными с уникальными именами
- Вызов функции - это просто jump
- Возврат - это jump обратно

Но это не решит проблему повторного использования кода.

## Рекомендация
Начнем с упрощенной модели:
1. Без стека вызовов
2. Локальные переменные = глобальные с уникальными именами  
3. Вызов функции = inline подстановка

Потом добавим стек для рекурсии.

Так проще реализовать и отладить.