//!math.bl
// Регистровая математика

// *ret = *a + *b
pub fn add(ret: *i16, a: *i16, b: *16) = 0x67 


//!mem.bl
// Управление памятью

// *target = value
pub fn load(target: *i16, value: i16) = ...


//!stack.bl
// Управление стеком

// *SP = *source
pub fn push_var(source: *i16) = ...

// SP = source
pub fn push_const(source: i16) = ...

// SP += len
pub fn alloc(len: usize) = ...

// *dest = pop()
pub fn pop_in(dest: *i16) = ...

//!func.bl
// Поддержка процедур и функций

// push(func); exec(func)
pub fn call(func: *void) = ...

// restore SP
pub fn ret() = ...


//!sketch.bl

import math
import stack
import func
import mem

// calc(x, y) = 5 + x + y
fn calc(
    x: i16, 
    y: i16,
) i16 {
    // Если процедура имеет возвращаемый тип, 
    // то в пространстве имён данной процедуры автоматически добавляется переменная result
    // с типом возвращаемого значения
    // var return: i16

    // return = 5
    mem.load(return, return, 5)
    
    // return = x + y
    math.add(return, x, y)
    
    // Восстанавливаем SP
    func.ret()
}

// Глобальная переменная, инициализирована
var x: i16 = 20

// Точка входа
fn main() void {

    // Вызов функции calc

    // Кладём на стек константу 100
    stack.push_const(100)

    // Кладём на стек значение переменной x
    stack.push_var(x)

    // calc имеет возвращаемое значение - аллоцируем под него. 
    stack.alloc(sizeof(calc.return))

    // Кладём в стек адрес возврата, переходим в calc
    func.call(calc)

    // Захват результата X
    func.pop_in(x)
}